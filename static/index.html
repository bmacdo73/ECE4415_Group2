<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Online Collection | AGGV</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body   onload = 'startup()'>
    <h1>The AGGV Online Collection</h1>
    <div class="cameraControlButtons">
        <button name="rotateTestLeft" id="rotateTestLeft">Rotate Left</button>
        <button name="rotateTestRight" id="rotateTestRight">Rotate Right</button>
        <button name="rotateTestUp" id="rotateTestUp">Rotate Up</button>
        <button name="rotateTestDown" id="rotateTestDown">Rotate Down</button>
        <button id = "start" onclick = 'startCapture()'>Begin Recording</button>
    </div>

    <script src="https://threejs.org/build/three.min.js"></script>
    <script type="module">
        //I don't like hard coding this in the html file but the librarys we're using requires it be done this way

        /*
        *----------------------------------------------------------------------------------------------------------------
        *
        *    three.js setup
        *
        *----------------------------------------------------------------------------------------------------------------
        */
        //import GLTFLoader files from the CDN
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three/examples/jsm/loaders/GLTFLoader.js';
        //import OrbitControls files from the CDN
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        //camera defaults to facing (0,0,0) along the negative z-axis
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        //controls.update() must be called after any manual changes to the camera's transform


        /*
        *----------------------------------------------------------------------------------------------------------------
        *
        *    GLTFLoader() - .glb file imports
        *
        *----------------------------------------------------------------------------------------------------------------
        */
        //add 3dbenchy
        const loader = new GLTFLoader();
        loader.load("./3d/3dbenchy.glb", function (gltf) {
            //define the material
            gltf.scene.traverse((child)=>{
                if (child.isMesh){
                    child.material = new THREE.MeshPhongMaterial({color: 0xff3f00, flatShading: true});
                }
            })
            scene.add(gltf.scene);
            console.log("3dbenchy.glb loaded successfully.");
        }, undefined, function (error) {
            console.error(error);
        });

        //add Vancouver Thunderbird Totem Pole
        loader.load("./3d/vancouverTotemPole.glb", function(gltf){
            //define the material
            gltf.scene.traverse((child)=>{
                if (child.isMesh){
                    child.material = new THREE.MeshStandardMaterial({color: 0x2c2017, flatShading: true});
                }
            })
            gltf.scene.position.set(-0.075,0,-0.1);
            scene.add(gltf.scene);
            console.log("vancouverTotemPole.glb loaded successfully.");
        }, undefined, function (error) {
            console.error(error);
        });

        //---------------------------------------------------------------------------------------------------------------

        //add lighting
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.25)
        scene.add(ambientLight)
        var rightPointLight = new THREE.PointLight(0xffffdd, 1);
        rightPointLight.position.set(25, 50, 25);
        scene.add(rightPointLight);
        var leftPointLight = new THREE.PointLight(0xffffdd, 1);
        leftPointLight.position.set(-25, 50, 25);
        scene.add(leftPointLight);

        //set camera back a bit and elevated a bit to see the object without it clipping
        camera.position.y = 0.067;
        camera.position.z = 0.2;
        //controls.update() must be called after any manual changes to the camera's transform
        controls.update();


        /*
        *----------------------------------------------------------------------------------------------------------------
        *
        *    Camera Manipulation - Functions to rotate along x- and y-axis in 30* increments
        *
        *----------------------------------------------------------------------------------------------------------------
        */
        
        /*
        * REMEBER!
        * Camera defaults to facing (0,0,0) along the negative z-axis
        * (x,y,z) ==> positive values move (right,up,backwards) to camera default position
        * Angles measured in rad
        * Maximum range for Azimuth angle is (-inf,+inf)
        * Maximum range for Polar is [0,pi] ==> cannot flip camera upside down. This is a feature not a bug!
        */ 

        //declarations
        var btnTestLeft = document.getElementById("rotateTestLeft");
        var btnTestRight = document.getElementById("rotateTestRight");
        var btnTestUp = document.getElementById("rotateTestUp");
        var btnTestDown = document.getElementById("rotateTestDown");
        const x = new THREE.Vector3(1,0,0);
        const y = new THREE.Vector3(0,1,0);

        //Negative rotation along the x-axis
        //"Rotate Up"
        /*btnTestUp.onclick = function rotateUp(){*/
        var rotateUp = function(){
            console.log("\n"+"Negative rotation along the x-axis!");
            console.log("Old angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle());
            camera.position.applyAxisAngle(x,(-30*Math.PI/180));
            controls.update();
            console.log("New angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle()+"\n"+" ");
        }
        //Positive rotation along the x-axis
        //"Rotate Down"
        /*btnTestDown.onclick = function rotateDown(){*/
        var rotateDown = function(){
            console.log("\n"+"Positive rotation along the x-axis!");
            console.log("Old angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle());
            camera.position.applyAxisAngle(x,(30*Math.PI/180));
            controls.update();
            console.log("New angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle()+"\n"+" ");
        }
        //Negative rotation along the y-axis
        //"Rotate Left"
        /*btnTestLeft.onclick = function rotateLeft(){*/
        function rotateLeft(){
            console.log("\n"+"Negative rotation along the y-axis!");
            console.log("Old angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle());
            camera.position.applyAxisAngle(y,(-30*Math.PI/180));
            controls.update();
            console.log("New angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle());
        }
        //Positive rotation along the y-axis
        //"Rotate Right"
        /*btnTestRight.onclick = function rotateRight(){*/
        var rotateRight = function(){
            console.log("\n"+"Positive rotation along the y-axis!");
            console.log("Old angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle());
            camera.position.applyAxisAngle(y,(30*Math.PI/180));
            controls.update();
            console.log("New angle: azimuth="+controls.getAzimuthalAngle()+"  polar="+controls.getPolarAngle()+"\n"+" ");
        }
    

        /*
        *----------------------------------------------------------------------------------------------------------------
        *
        *    Animation and rendering calls - this is where the magic happens
        *
        *----------------------------------------------------------------------------------------------------------------
        */
        animate();

        function animate() {
            requestAnimationFrame(animate);

            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.render(scene, camera);
        };


        /*
        *----------------------------------------------------------------------------------------------------------------
        *
        *    Webcam/Motion Capture code below
        *
        *----------------------------------------------------------------------------------------------------------------
        */

        



 
    </script>

    <script>
//FINAL VARIABLES
let video = null; //Holds the video feed from the webcam
let vidHeight = 0; //Video height
let vidWidth = 0; //Video width

var diffCanvas = null; // canvas to hold the difference
var diffContext = null; //context for diffCanvas
var diffImage = null; //image data from diffCanvas

let xMotion = "None"; //The current detected motion in the x axis
let yMotion = "None"; //The current detected motion in the y axis

let yDiv = []; //The divisions for the y axis
let xDiv = []; //The divisions for the x axis

let xDivI = 0; //Index of biggest division in the x axis
let yDivI = 0; //Index of biggest division in the y axis
let xDivILast = 0; //Last index of the biggest division in the x axis
let yDivILast = 0; //Last index of the biggest division in the y axis

let xP = 0; //Percentage of distance in x axis travelled
let yP = 0; //Percentage of distance in y axis travelled

let onStart = false; //Check if the recording has started already

const pixelThresh = 0.4; //Threshold at which pixels have enough movement to be counted
const idealWidth = 310; //The ideal value for width the program will seek from the webcam
const idealHeight = 240; //The ideal value for height the program will seek from the webcam
const frameTime = 50; //Time in ms between frames
const rMult = 0.299; //Multiplier for red values of pixels for weighted average
const gMult = 0.587; //Multiplier for green values of pixels for weighted average
const bMult = 0.114; //Multiplier for blue values of pixels for weighted average
const xDivAmount = 4; //Amount of divisions in the x axis
const yDivAmount = 3; //Amount of divisions in the y axis
const xMult = 1.00; //How much more motion must be in new x division to count
const yMult = 1.00; //How much more motion must be in new y division to count




function startup() {
  console.log("Script starting up!");
  video = document.createElement('video');
  video.height = idealHeight;
  video.width = idealWidth;
  video.autoplay = true;

  if (navigator.mediaDevices.getUserMedia) {
  navigator.mediaDevices.getUserMedia({ audio: false,video: {width: {ideal:idealWidth},height: {ideal:idealHeight} }})
    .then(function (stream) {
      console.log("Gets this far!");
      video.srcObject = stream; 

    })
    .catch(function (err0r) {
      console.log("Something went wrong!");
    });
}


  //TEST
  //Initialise the array:
  for (var i = 0; i < xDivAmount; i++){
    xDiv.push(0);
    yDiv.push(0);
  }
}

function startCapture(){
    console.log("Begin recording pressed");
  if (!onStart){
  onStart = true;
  console.log("start capture runs!");
  //TEST
  vidHeight = video.videoHeight;
  vidWidth = video.videoWidth;
  console.log(vidHeight + ", " + vidWidth);
  //Setup canvases
  diffCanvas = document.createElement('canvas');
  diffCanvas.height = vidHeight;
  diffCanvas.width = vidWidth;
  diffContext = diffCanvas.getContext('2d');

  setInterval(blend, frameTime);  
  }
}

//Function to stop the webcam
function stop(e) {
  var stream = video.srcObject;
  var tracks = stream.getTracks();

  for (var i = 0; i < tracks.length; i++) {
    var track = tracks[i];
    track.stop();
  }

  video.srcObject = null;
}

//Takes two frames from the webcam and compares them
function blend() {

  //GOOD VERSION
  //console.log("Blend has started");
  
  //Create an image data to hold the difference between current frame and last frame
  diffImage = diffContext.createImageData(vidWidth, vidHeight);

  //Take the difference between a downscaled current frame and previous frame
  diffContext.globalCompositeOperation = 'difference';
  diffContext.drawImage(video, 0, 0, vidWidth, vidHeight);
  diffImage = diffContext.getImageData(0, 0, vidWidth, vidHeight);

  //Create variables to be used in the loop
  let x = 0;
  let y = 0;
  let r = 0;
  let b = 0;
  let g = 0;
  let pixelScore = 0;

  //TEST
  //Reset the array:
  for (var i = 0; i < xDivAmount; i++){
    xDiv[i] = 0;
    yDiv[i] = 0;
  }

  // Iterate through every pixel
  for (let i = 0; i < diffImage.data.length; i += 4) {

    // y value of the pixel
    y = Math.floor(i/(vidWidth * 4));
    // x value of the pixel
    x = Math.floor((i - (y * vidWidth * 4))/4);
  
    // Gather weighted r, g, and b values and take the total
    r = diffImage.data[i + 0] * rMult;  // R value
    g = diffImage.data[i + 1] * gMult;  // G value
    b = diffImage.data[i + 2] * bMult;  // B value
    pixelScore = (r + g + b)/ 255;

    //TESTING
    if (pixelScore > pixelThresh){
      //Take down red and blue, send green way up
      diffImage.data[i + 0] = 0;  // R value
      diffImage.data[i + 1] = pixelScore * 255;  // G value
      diffImage.data[i + 2] = 0;  // B value

      //TESTING
      xDiv[Math.floor((x/vidWidth)*(xDivAmount))]++;
      yDiv[Math.floor((y/vidHeight)*(yDivAmount))]++;
    }

    //TESTING
    //Set up horizontal lines
    if ((y%Math.floor(vidHeight/yDivAmount)) == 0){
      diffImage.data[i + 1] = 0;
      diffImage.data[i + 0] = 255;
    }

    //Set up vertical lines
    if( (x%Math.floor(vidWidth/xDivAmount)) == 0){
      diffImage.data[i + 1] = 0;
      diffImage.data[i + 0] = 255;
    }


  }

  //TEST
  //Find the largest divisions:
  for (var i = 0; i < xDivAmount; i++){
    if(xDiv[i] > xDiv[xDivI] * xMult){
      xDivI = i; 
    }
  }

  for (var i = 0; i < yDivAmount; i++){
    if(yDiv[i] > yDiv[yDivI] * yMult){
      yDivI = i; 
    }
  }

  //Check which direction movement has been if there has been any
  if (xDivI < xDivILast){
    xMotion = "Right";
    xP += xDivILast - xDivI;
    rotateRight();
  } else if (xDivI > xDivILast){
    xMotion = "Left";
    xP += xDivI - xDivILast;
    rotateLeft();
  } else {
    //console.log("Percent travelled in x direction: " + xP/xDivAmount); 
    xP = 0;
    xMotion = "None"
  }

  if (yDivI < yDivILast){
    yMotion = "Up";
    yP += yDivILast - yDivI;
    rotateUp();
  } else if (yDivI > yDivILast){
    yMotion = "Down";
    yP += yDivI - yDivILast;
    rotateDown();
  } else {
    yMotion = "None"
    //console.log("Percent travelled in y direction: " + yP/yDivAmount); 
    yP = 0;
  }

  //document.getElementById('xMotionLabel').innerText = xMotion;
  //document.getElementById('yMotionLabel').innerText = yMotion;
  xDivILast = xDivI;
  yDivILast = yDivI;

  //TEST
  //Print out the frame to the test canvas
  /*
  let testCtx = document.getElementById('testCanvas').getContext('2d');
  testCtx.putImageData(diffImage,0,0);*/

  // draw current capture normally over diff, ready for next time
  diffContext.globalCompositeOperation = 'source-over';
  diffContext.drawImage(video, 0, 0, vidWidth, vidHeight);

  //console.log("Blend has finished");
}
    </script>

</body>
</html>